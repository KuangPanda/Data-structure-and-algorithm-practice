## 树(Tree)

### 基本概念

* 树是n个节点的有限集, n=0时称为空树. 在任意一棵非空树中, 有且仅有一个特定的称为根的节点. 当n>1时, 其余节点可分为m个互不相交的有限集T\_1, T\_2...T_m, 其中每一个集合本身又是一棵树, 并且称为根的子树.
  * n > 0时根节点是唯一的, 不可能存在多个根节点
  * m > 0时, 子树的个数没有限制, 但它们一定是互不相交的.
* 一棵树是N个节点和N-1条边的集合, 其中的一个节点叫做根. 每条边都将某个节点连接到它的父亲, 而除去根节点外每一个节点都有且仅有一个父亲.
* 树的节点包含一个数据元素及若干指向其子树的分支, 节点拥有的子树个数称为节点的度. 度为0的节点称为叶节点或终端节点; 度不为0的节点称为非终端节点或分支节点, 除根节点之外, 分支节点也称为内部节点. 树的度是树内各节点的度的最大值.

![tree_1](/home/victory/Study/Data-structure-and-algorithm-practice/tree/tree_1.jpg)



* 节点的子树的根称为该节点的孩子(子节点), 该节点称为孩子的双亲, 同一个双亲的孩子之间互称为兄弟. 节点的祖先是从根到该节点所经分支上的所有节点. 以某节点为根的子树中的任一节点都称为该节点的子孙.
* 节点的层次从根开始定义, 根为第一层, 根的孩子为第二层. 其双亲在同一层的节点互为堂兄弟. 树中节点的最大层次称为树的高度或深度. 若将树中每个节点的各子树看成是从左到右有次序的(即不能互换), 则称该树为有序树, 否则为无序树.

![tree_2](/home/victory/Study/Data-structure-and-algorithm-practice/tree/tree_2.jpg)

* 森林是m棵互不相交的树的集合. 对树中每个节点而言, 其子树的集合即为森林. 树和森林的概念相近, 删去一棵树的根, 就得到一个森林. 反之, 加上一个节点作树根, 森林就变为一棵树.


### 存储

* ​

### 遍历

* ​



## 二叉树

### 基本概念

* 二叉树是一棵树, 其中每个节点都不能有多于两个的儿子.
* 二叉树的一个性质是平均二叉树的深度要比N小得多, 平均深度为O($$\sqrt{N}$$). 二叉查找树深度的平均值是O($$Nlog{N}$$).

### 存储

* 具有N个节点的二叉树都将需要N+1个NULL指针.

  ```c
  typedef struct TreeNode *PtrToNode 
  typedef struct PtrToNode Tree
  struct TreeNode
  {
  	ElementType Element;
    	Tree Left;
    	Tree Right;
  };
  ```

### 遍历

* 先序遍历
  * 优先访问根节点, 再先序遍历左子树, 然后再先序遍历右子树.
* 中序遍历
  * 中序遍历左子树, 再访问根节点, 然后中序遍历右子树.
* 后序遍历
  * 后序遍历左子树, 再后序遍历右子树, 然后再访问根节点.



## 二叉搜索树(BST)

* 对于树中的每个节点X, 它的左子树中所有关键字值小于X的关键字值. 它的右子树中所有关键字值大于X的关键字值.


* 删除
  * 叶子节点: 可以立即删除.
  * 有一个子节点的父节点: 该节点可以在其父节点调整指针绕过该节点后被删除.
  * 有两个子节点的父节点: 用其右子树的最小的数据代替该节点的数据并递归地删除那个节点.

## 二叉查找树(AVL)

* AVL树是带有平衡条件的二叉查找树, 保证树的深度是O($$logN$$). 一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树.



























### 树(TREE)

#### 深度和高度

* 高度：从节点x向下到某个叶节点最长简单路径中边的条数
* 深度：深度是从根往下数，一般根节点是1

#### 二叉查找树(BST)

* 性质
  * 若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值
  * 若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值
  * 它的左右子树也分别为二叉查找树
* 插入
  * 二叉树中插入新的节点，要保证插入新节点后仍能满足二叉查找树的性质。
  * 若二叉查找树的根节点为空，则使新的节点为根
  * 若二叉查找树root不为空，新节点小于插入点的关键字，则将新节点插入到左子树，否则右子树
* 删除
  * 若删除点是叶子节点，则设置其父节点的指针为空
  * 若删除点只有左子树或者是只有右子树，则设置其父节点的指针指向删除点的左子树或右子树
  * 若删除点的左右子树均不为空，则用其右子树的最小的数据代替该节点的数据并递归的删除那个节点



#### AVL树

> 二叉搜索树，只是它在插入元素的时候，每插入一个新节点的时候就会调整整棵树的结构，从而保证树的平衡。即每个节点的左右子树高度差的绝对值不超过1.

* 性质

  * 左右子树都是AVL树，左右子树的高度之差的绝对值不超过1
  * 如果AVL树有n的节点，则它的高度可以保持在log(n)，那么平均搜索时间复杂度为O(log(n))
  * **平衡因子** 对于任意节点x，其平衡因子定义为该节点右子树和左子树高度差，即bf(x) = h(x-right) - h(x-left)。带有平衡因子1, 0，或者是-1的节点被认为是平衡的。带有平衡因子-2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来

* 旋转操作

  > AVL树在插入和删除节点造成不平衡的时候需要对发生不平衡的节点及时进行调整，旋转操作

  * 单旋(LL型和RR型)

    **在B节点的左子树上插入节点导致A节点失衡**，调整过程**以B节点为轴心，A节点顺时针旋转至B的右子树，A的左子树由B的右子树代替，通过右旋操作返回以为root的平衡子树**

  * 双旋

    **在B节点的右子树上插入新节点导致A节点失衡** ，调整过程为**首先以C为轴心，B绕C逆时针旋转，生成的子树作为A的左子树；这样就变成LL型然后照上面来，通过先左旋再右旋，返回以C为root的平衡子树**
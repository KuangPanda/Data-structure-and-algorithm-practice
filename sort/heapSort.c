//2017-03-30
//堆排序, 是一种树型选择排序 
#include<stdio.h>
#include<stdlib.h>

// 设树深度为k，。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式： 
// 而建堆时的比较次数不超过4n 次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn )
/* 基本思想
 * 堆的定义： 具有n个元素的序列(k1, k2, ..., kn), 当且仅当满足 k(i) < k(2i+1) && k(i) < k(2i) (最小堆)， k(i) > k(2i+1) && k(i) > k(2i) (最大堆) i = 1, 2, ...., n/2.
 * 若以一阶数组的形式存储一个堆，则堆对应一棵完全二叉树，且所有非叶节点的值均不大于(或不小于)其子女的值， 根节点(堆顶元素)的值是最大(最小)的。
 * 初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。
 * 然后对剩余(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。
 * 因此，实现堆排序需解决两个问题： 1. 如何将n 个待排序的数建成堆； 2. 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。
*/

/* 首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。（筛选）
 * 调整小顶堆的方法：
 * 1. 设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。
 * 2. 将根结点与左、右子树中较小元素的进行交换。
 * 3.若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.
 * 4.若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.
 * 5.继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。
 * 称这个自根结点到叶子结点的调整过程为筛选。
 * 再讨论对n 个元素初始建堆的过程。建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。
 * 1.n 个结点的完全二叉树，则最后一个结点是第个结点的子树。
 * 2.筛选从第个结点为根的子树开始，该子树成为堆。
 * 3.之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。
*/

/* 已知H[s..m]除了H[s]外均满足堆的定义，调整H[s],使其成为大顶堆。（对第s个节点为根的子树进行筛选）
 * @param arr是待调整的堆数组
 * @param S是待调整的数组元素的位置
 * @param length是数组的长度
*/
int heapAdjust(int arr[], int s, int length) {
    int temp = arr[s];
    int child = 2 * s + 1;
    while(child < length) {
        if((child + 1) < length && arr[child] < arr[child + 1]) {
            ++child;
        }
        if(arr[s] < arr[child]) {
            arr[s] = arr[child];
            s = child;
            child = 2 * s + 1;
        }
        else {
            break;
        }
        arr[s] = temp;
    }
    return 0;
}

/* BuildHeap
 * 初始堆进行调整，将arr[0...length - 1]建成堆
*/
int buildHeap(int arr[], int length) {
    int i = 0;
    for(i = (length - 1) / 2; i >= 0; i--) {
        heapAdjust(arr, i, length);
    }
}

/* heapSort
*/
int heapSort(int arr[], int length) {
    int temp = 0;
    int i = 0;
    buildHeap(arr, length);
    for(i = length - 1; i > 0; i--) {
        temp = arr[i];
        arr[i] = arr[0];
        arr[0] = temp; //交换堆顶的元素和堆中最后一个元素
        heapAdjust(arr, 0, i);
    }
    return 0;
}

int main() {
    int arr[10] = {987, 876, 765, 654, 543, 432, 321, 98, 87, 76};
    int i = 0;
    heapSort(arr, 10);
    for(i = 0; i < 10; i++) {
        printf("%d\t", arr[i]);
    }
    return 0;
}